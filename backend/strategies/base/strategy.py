"""
Base strategy abstract class.

All trading strategies inherit from BaseStrategy and implement
the required methods for signal generation and configuration.
"""

from abc import ABC, abstractmethod
from datetime import date
from typing import List, Optional, Callable, TYPE_CHECKING

if TYPE_CHECKING:
    from strategies.base.config import StrategyConfig
    from strategies.base.filter import EntryFilter
    from app.models.schemas import BacktestResult


class TradingSignal:
    """
    Represents a trading signal generated by a strategy.

    Attributes:
        signal_type: Type of signal (BUY_CALL, BUY_PUT, NO_SIGNAL)
        timestamp: When the signal was generated
        price: Underlying price at signal time
        reason: Human-readable reason for the signal
        metadata: Additional signal-specific data
    """

    def __init__(
        self,
        signal_type: str,
        timestamp,
        price: float,
        reason: str = "",
        metadata: Optional[dict] = None,
    ):
        self.signal_type = signal_type
        self.timestamp = timestamp
        self.price = price
        self.reason = reason
        self.metadata = metadata or {}

    def __repr__(self) -> str:
        return f"TradingSignal({self.signal_type}, {self.timestamp}, ${self.price:.2f})"


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.

    Each strategy must implement:
    - name: Unique identifier
    - description: Human-readable description
    - generate_signals(): Signal generation logic
    - get_default_config(): Default configuration

    Strategies can optionally override:
    - get_entry_filters(): Additional entry conditions
    - get_exit_strategy(): Custom exit logic
    """

    @property
    @abstractmethod
    def name(self) -> str:
        """
        Unique strategy identifier (e.g., 'morning_fade', 'iv_rank').

        Used for:
        - Strategy registry lookup
        - Results file naming
        - CLI selection
        """
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Human-readable strategy description."""
        pass

    @abstractmethod
    def get_default_config(self) -> "StrategyConfig":
        """
        Return default configuration for this strategy.

        Returns:
            StrategyConfig instance with sensible defaults
        """
        pass

    @abstractmethod
    async def generate_signals(
        self,
        bars: List[dict],
        config: "StrategyConfig",
    ) -> List[TradingSignal]:
        """
        Generate entry signals for the given bars.

        This is the core strategy logic. Implementations should:
        1. Process bars to detect entry conditions
        2. Return TradingSignal objects for each potential entry

        Args:
            bars: OHLCV bars with keys: timestamp, open, high, low, close, volume
            config: Strategy configuration

        Returns:
            List of TradingSignal objects (one per bar, use NO_SIGNAL for no entry)
        """
        pass

    def get_entry_filters(self) -> List["EntryFilter"]:
        """
        Return list of entry filters to apply after signal generation.

        Filters can reject signals based on:
        - Time of day
        - Volatility conditions (IV rank)
        - Market regime
        - etc.

        Default: no additional filters (all signals pass).
        Override to add strategy-specific filtering.

        Returns:
            List of EntryFilter instances
        """
        return []

    async def run_backtest(
        self,
        start_date: date,
        end_date: date,
        config: Optional["StrategyConfig"] = None,
        progress_callback: Optional[Callable[[int, int], None]] = None,
    ) -> "BacktestResult":
        """
        Run backtest for this strategy.

        Uses StrategyRunner to execute the backtest with:
        1. Strategy's signal generation
        2. Strategy's entry filters
        3. Strategy's exit logic

        Args:
            start_date: Backtest start date
            end_date: Backtest end date
            config: Strategy configuration (uses default if None)
            progress_callback: Optional callback for progress updates

        Returns:
            BacktestResult with trades, metrics, and equity curve
        """
        from strategies.base.runner import StrategyRunner

        runner = StrategyRunner(self)
        return await runner.run(start_date, end_date, config, progress_callback)

    def validate_config(self, config: "StrategyConfig") -> List[str]:
        """
        Validate strategy configuration.

        Override to add strategy-specific validation rules.

        Args:
            config: Configuration to validate

        Returns:
            List of validation error messages (empty if valid)
        """
        errors = []

        if config.start_date and config.end_date:
            if config.start_date >= config.end_date:
                errors.append("start_date must be before end_date")

        if config.initial_capital <= 0:
            errors.append("initial_capital must be positive")

        return errors

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name={self.name})"
