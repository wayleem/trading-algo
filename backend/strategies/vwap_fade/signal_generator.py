"""
VWAP Fade Signal Generator.

Generates signals when price deviates below VWAP in the first 30 minutes.
Only trades the structural edge from institutional VWAP targeting.
"""

from typing import Optional, List
from datetime import datetime, date, time
from dataclasses import dataclass
from enum import Enum
import logging

from app.models.schemas import SignalType

logger = logging.getLogger(__name__)


class VWAPState(Enum):
    """State of the VWAP fade strategy for the current day."""
    BUILDING_VWAP = "building_vwap"  # Collecting bars to build VWAP
    WATCHING = "watching"  # VWAP established, watching for deviation
    SIGNAL_FIRED = "signal_fired"  # Signal generated, done for day
    WINDOW_CLOSED = "window_closed"  # Past entry window, no more signals
    DONE_FOR_DAY = "done_for_day"


@dataclass
class VWAPSignal:
    """Signal generated by VWAP fade strategy."""
    signal_type: SignalType
    timestamp: datetime
    price: float
    vwap: float
    deviation_pct: float
    reason: str


class VWAPFadeSignalGenerator:
    """
    Generate trading signals based on VWAP deviation fading.

    Constraints (based on validation):
    - Entry window: 9:35-10:00 AM ET only (first 25 minutes after VWAP stabilizes)
    - Direction: Below VWAP only (fade up with calls)
    - Deviation: 0.3% minimum
    - Exit deadline: 10:30 AM ET

    State Machine:
        BUILDING_VWAP -> WATCHING -> SIGNAL_FIRED
                                  -> WINDOW_CLOSED (if no signal by 10:00 AM)
    """

    def __init__(
        self,
        deviation_threshold_pct: float = 0.3,
        max_deviation_pct: float = 1.0,
        fade_below_vwap: bool = True,
        fade_above_vwap: bool = False,
        entry_start_hour_utc: int = 14,
        entry_start_minute_utc: int = 35,
        entry_cutoff_hour_utc: int = 15,
        max_entries_per_day: int = 1,
        min_bars_for_vwap: int = 5,  # Need at least 5 bars before VWAP is meaningful
    ):
        self.deviation_threshold_pct = deviation_threshold_pct
        self.max_deviation_pct = max_deviation_pct
        self.fade_below_vwap = fade_below_vwap
        self.fade_above_vwap = fade_above_vwap
        self.entry_start_hour_utc = entry_start_hour_utc
        self.entry_start_minute_utc = entry_start_minute_utc
        self.entry_cutoff_hour_utc = entry_cutoff_hour_utc
        self.max_entries_per_day = max_entries_per_day
        self.min_bars_for_vwap = min_bars_for_vwap

        # State tracking
        self.current_date: Optional[date] = None
        self.state: VWAPState = VWAPState.BUILDING_VWAP
        self.entries_today: int = 0

        # VWAP calculation
        self.cumulative_pv: float = 0.0  # Price * Volume
        self.cumulative_volume: float = 0.0
        self.vwap: float = 0.0
        self.bars_processed: int = 0

    def reset_for_new_day(self) -> None:
        """Reset state for a new trading day."""
        self.state = VWAPState.BUILDING_VWAP
        self.entries_today = 0
        self.cumulative_pv = 0.0
        self.cumulative_volume = 0.0
        self.vwap = 0.0
        self.bars_processed = 0

    def _update_vwap(self, bar: dict) -> None:
        """Update running VWAP with new bar."""
        typical_price = (bar["high"] + bar["low"] + bar["close"]) / 3
        volume = bar.get("volume", 0)

        if volume > 0:
            self.cumulative_pv += typical_price * volume
            self.cumulative_volume += volume
            self.vwap = self.cumulative_pv / self.cumulative_volume

        self.bars_processed += 1

    def _is_in_entry_window(self, bar_time: datetime) -> bool:
        """Check if current time is within entry window."""
        hour = bar_time.hour
        minute = bar_time.minute

        # Entry starts at entry_start_hour_utc:entry_start_minute_utc
        start_minutes = self.entry_start_hour_utc * 60 + self.entry_start_minute_utc
        current_minutes = hour * 60 + minute

        # Entry ends at entry_cutoff_hour_utc:00
        end_minutes = self.entry_cutoff_hour_utc * 60

        return start_minutes <= current_minutes < end_minutes

    def _is_past_entry_window(self, bar_time: datetime) -> bool:
        """Check if we're past the entry window."""
        hour = bar_time.hour
        return hour >= self.entry_cutoff_hour_utc

    def process_bar(self, bar: dict) -> Optional[VWAPSignal]:
        """
        Process a price bar and potentially generate a signal.

        Args:
            bar: Price bar with keys: timestamp, open, high, low, close, volume

        Returns:
            VWAPSignal if deviation detected in entry window, None otherwise
        """
        bar_time = bar["timestamp"]
        if isinstance(bar_time, str):
            bar_time = datetime.fromisoformat(bar_time.replace("Z", "+00:00"))

        bar_date = bar_time.date()

        # Check for new day
        if self.current_date is None or bar_date != self.current_date:
            self.reset_for_new_day()
            self.current_date = bar_date

        # Always update VWAP
        self._update_vwap(bar)

        # Check if past entry window
        if self._is_past_entry_window(bar_time):
            if self.state not in (VWAPState.SIGNAL_FIRED, VWAPState.DONE_FOR_DAY):
                self.state = VWAPState.WINDOW_CLOSED
            return None

        # State machine
        if self.state == VWAPState.BUILDING_VWAP:
            if self.bars_processed >= self.min_bars_for_vwap:
                self.state = VWAPState.WATCHING
                logger.debug(f"VWAP established: ${self.vwap:.2f} after {self.bars_processed} bars")
            return None

        if self.state == VWAPState.WATCHING:
            return self._check_for_deviation(bar, bar_time)

        return None

    def _check_for_deviation(self, bar: dict, bar_time: datetime) -> Optional[VWAPSignal]:
        """Check for tradeable deviation from VWAP."""
        if not self._is_in_entry_window(bar_time):
            return None

        if self.entries_today >= self.max_entries_per_day:
            return None

        if self.vwap <= 0:
            return None

        price = bar["close"]
        deviation_pct = (price - self.vwap) / self.vwap * 100

        # Check if deviation is tradeable
        if abs(deviation_pct) < self.deviation_threshold_pct:
            return None

        if abs(deviation_pct) > self.max_deviation_pct:
            logger.debug(f"Deviation {deviation_pct:.2f}% exceeds max {self.max_deviation_pct}%")
            return None

        # Check direction filter
        if deviation_pct < 0 and not self.fade_below_vwap:
            return None
        if deviation_pct > 0 and not self.fade_above_vwap:
            return None

        # Generate signal
        return self._generate_signal(bar, bar_time, deviation_pct)

    def _generate_signal(
        self, bar: dict, bar_time: datetime, deviation_pct: float
    ) -> VWAPSignal:
        """Generate the fade signal based on deviation direction."""
        self.entries_today += 1
        self.state = VWAPState.SIGNAL_FIRED

        price = bar["close"]

        if deviation_pct < 0:
            # Below VWAP -> fade up -> BUY CALL
            signal_type = SignalType.BUY_CALL
            reason = f"Below VWAP by {abs(deviation_pct):.2f}% - fading up with call"
        else:
            # Above VWAP -> fade down -> BUY PUT
            signal_type = SignalType.BUY_PUT
            reason = f"Above VWAP by {deviation_pct:.2f}% - fading down with put"

        logger.info(f"VWAP Fade Signal: {signal_type.name} @ ${price:.2f} (VWAP: ${self.vwap:.2f})")

        return VWAPSignal(
            signal_type=signal_type,
            timestamp=bar_time,
            price=price,
            vwap=self.vwap,
            deviation_pct=deviation_pct,
            reason=reason,
        )

    def get_vwap_info(self) -> dict:
        """Get current VWAP information."""
        return {
            "vwap": self.vwap,
            "bars_processed": self.bars_processed,
            "state": self.state.value,
            "entries_today": self.entries_today,
        }

    def get_current_deviation(self, price: float) -> float:
        """Calculate current deviation from VWAP."""
        if self.vwap <= 0:
            return 0.0
        return (price - self.vwap) / self.vwap * 100
