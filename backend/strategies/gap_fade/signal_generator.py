"""
Gap Fade Signal Generator.

State machine that detects overnight gaps and generates fade signals.
Tracks prior day close to calculate gap on market open.
"""

from typing import Optional
from datetime import datetime, date, time
from dataclasses import dataclass
from enum import Enum
import logging

from app.models.schemas import SignalType

logger = logging.getLogger(__name__)


# Market hours in UTC (ET + 5 during EST, ET + 4 during EDT)
# Assuming 1-minute bars, 9:30 AM ET = 14:30 UTC (winter) or 13:30 UTC (summer)
MARKET_OPEN_HOUR_UTC = 14  # Approximate - adjusted in code


class GapState(Enum):
    """State of the gap fade strategy for the current day."""
    AWAITING_OPEN = "awaiting_open"  # Before market open, no prior close yet
    GAP_DETECTED = "gap_detected"  # Gap calculated, waiting for entry window
    WAITING_FOR_ENTRY = "waiting_for_entry"  # In entry delay period
    SIGNAL_FIRED = "signal_fired"  # Signal generated, done for day
    DONE_FOR_DAY = "done_for_day"  # No trade today (no gap or gap too large)


@dataclass
class GapSignal:
    """Signal generated by gap fade strategy."""
    signal_type: SignalType
    timestamp: datetime
    price: float
    gap_pct: float
    prior_close: float
    current_open: float
    reason: str


class GapFadeSignalGenerator:
    """
    Generate trading signals based on overnight gap fading.

    State Machine:
        AWAITING_OPEN -> GAP_DETECTED -> WAITING_FOR_ENTRY -> SIGNAL_FIRED
                     -> DONE_FOR_DAY (if no tradeable gap)

    Usage:
        generator = GapFadeSignalGenerator(config)

        for bar in bars:
            signal = generator.process_bar(bar)
            if signal:
                # Execute trade
    """

    def __init__(
        self,
        gap_threshold_pct: float = 0.3,
        max_gap_pct: float = 1.5,
        fade_gap_up: bool = True,
        fade_gap_down: bool = True,
        entry_delay_minutes: int = 5,
        entry_window_minutes: int = 15,
        entry_cutoff_hour_utc: int = 15,
        max_entries_per_day: int = 1,
    ):
        """
        Initialize Gap Fade Signal Generator.

        Args:
            gap_threshold_pct: Minimum gap size to trade (0.3% = ~$1.50 SPY)
            max_gap_pct: Maximum gap size (1.5% = ~$7 SPY)
            fade_gap_up: Whether to fade gap ups (buy puts)
            fade_gap_down: Whether to fade gap downs (buy calls)
            entry_delay_minutes: Minutes to wait after open before entry
            entry_window_minutes: Window during which entry is allowed
            entry_cutoff_hour_utc: Hour (UTC) after which no new entries
            max_entries_per_day: Maximum entries per day (typically 1)
        """
        self.gap_threshold_pct = gap_threshold_pct
        self.max_gap_pct = max_gap_pct
        self.fade_gap_up = fade_gap_up
        self.fade_gap_down = fade_gap_down
        self.entry_delay_minutes = entry_delay_minutes
        self.entry_window_minutes = entry_window_minutes
        self.entry_cutoff_hour_utc = entry_cutoff_hour_utc
        self.max_entries_per_day = max_entries_per_day

        # State tracking
        self.current_date: Optional[date] = None
        self.prior_close: Optional[float] = None
        self.current_open: Optional[float] = None
        self.gap_pct: Optional[float] = None
        self.state: GapState = GapState.AWAITING_OPEN
        self.entries_today: int = 0
        self.first_bar_time: Optional[datetime] = None

        # Track last bar for prior close calculation
        self._last_bar: Optional[dict] = None

    def reset_for_new_day(self, new_date: date) -> None:
        """Reset state for a new trading day."""
        # Save prior close from last bar of previous day
        if self._last_bar is not None:
            self.prior_close = self._last_bar["close"]

        self.current_date = new_date
        self.current_open = None
        self.gap_pct = None
        self.state = GapState.AWAITING_OPEN
        self.entries_today = 0
        self.first_bar_time = None

    def process_bar(self, bar: dict) -> Optional[GapSignal]:
        """
        Process a price bar and potentially generate a signal.

        Args:
            bar: Price bar with keys: timestamp, open, high, low, close

        Returns:
            GapSignal if entry conditions met, None otherwise
        """
        bar_time = bar["timestamp"]
        if isinstance(bar_time, str):
            bar_time = datetime.fromisoformat(bar_time.replace("Z", "+00:00"))

        bar_date = bar_time.date()

        # Check for new day
        if self.current_date is None or bar_date != self.current_date:
            self.reset_for_new_day(bar_date)

        # Update last bar for prior close tracking
        self._last_bar = bar

        # Check entry cutoff
        if bar_time.hour >= self.entry_cutoff_hour_utc:
            if self.state != GapState.DONE_FOR_DAY:
                self.state = GapState.DONE_FOR_DAY
            return None

        # State machine
        if self.state == GapState.AWAITING_OPEN:
            return self._handle_awaiting_open(bar, bar_time)
        elif self.state == GapState.GAP_DETECTED:
            return self._handle_gap_detected(bar, bar_time)
        elif self.state == GapState.WAITING_FOR_ENTRY:
            return self._handle_waiting_for_entry(bar, bar_time)

        return None

    def _handle_awaiting_open(self, bar: dict, bar_time: datetime) -> Optional[GapSignal]:
        """
        Handle first bar of day - detect gap.

        This is the first bar after market open. Calculate gap from prior close.
        """
        # No prior close yet (first day of data)
        if self.prior_close is None:
            self.state = GapState.DONE_FOR_DAY
            return None

        # Record market open
        self.current_open = bar["open"]
        self.first_bar_time = bar_time

        # Calculate gap percentage
        self.gap_pct = (self.current_open - self.prior_close) / self.prior_close * 100

        logger.debug(
            f"Gap detected: {self.gap_pct:+.2f}% "
            f"(Prior close: ${self.prior_close:.2f}, Open: ${self.current_open:.2f})"
        )

        # Check if gap is tradeable
        abs_gap = abs(self.gap_pct)

        if abs_gap < self.gap_threshold_pct:
            # Gap too small - no trade
            self.state = GapState.DONE_FOR_DAY
            logger.debug(f"Gap {abs_gap:.2f}% below threshold {self.gap_threshold_pct}%")
            return None

        if abs_gap > self.max_gap_pct:
            # Gap too large - likely trend day, don't fade
            self.state = GapState.DONE_FOR_DAY
            logger.debug(f"Gap {abs_gap:.2f}% exceeds max {self.max_gap_pct}%")
            return None

        # Check direction filter
        if self.gap_pct > 0 and not self.fade_gap_up:
            self.state = GapState.DONE_FOR_DAY
            return None
        if self.gap_pct < 0 and not self.fade_gap_down:
            self.state = GapState.DONE_FOR_DAY
            return None

        # Gap is tradeable - move to waiting for entry
        self.state = GapState.GAP_DETECTED
        logger.info(
            f"Tradeable gap: {self.gap_pct:+.2f}% - "
            f"will fade {'down' if self.gap_pct > 0 else 'up'}"
        )

        # If no entry delay, generate signal immediately
        if self.entry_delay_minutes == 0:
            return self._generate_signal(bar, bar_time)

        return None

    def _handle_gap_detected(self, bar: dict, bar_time: datetime) -> Optional[GapSignal]:
        """
        Wait for entry delay period to pass.

        We wait 5-10 minutes after open for the initial volatility to settle.
        """
        if self.first_bar_time is None:
            return None

        # Calculate minutes since market open
        minutes_since_open = (bar_time - self.first_bar_time).total_seconds() / 60

        if minutes_since_open >= self.entry_delay_minutes:
            self.state = GapState.WAITING_FOR_ENTRY
            return self._handle_waiting_for_entry(bar, bar_time)

        return None

    def _handle_waiting_for_entry(self, bar: dict, bar_time: datetime) -> Optional[GapSignal]:
        """
        Entry window is open - generate signal.

        We're past the delay period and within the entry window.
        """
        if self.first_bar_time is None:
            return None

        # Check if still within entry window
        minutes_since_open = (bar_time - self.first_bar_time).total_seconds() / 60
        window_end = self.entry_delay_minutes + self.entry_window_minutes

        if minutes_since_open > window_end:
            # Entry window closed
            self.state = GapState.DONE_FOR_DAY
            logger.debug("Entry window closed without signal")
            return None

        # Check max entries
        if self.entries_today >= self.max_entries_per_day:
            self.state = GapState.DONE_FOR_DAY
            return None

        # Generate signal
        return self._generate_signal(bar, bar_time)

    def _generate_signal(self, bar: dict, bar_time: datetime) -> Optional[GapSignal]:
        """
        Generate the fade signal based on gap direction.

        Gap UP -> BUY PUT (expect price to fall back)
        Gap DOWN -> BUY CALL (expect price to rise back)
        """
        if self.gap_pct is None or self.prior_close is None or self.current_open is None:
            return None

        self.entries_today += 1
        self.state = GapState.SIGNAL_FIRED

        if self.gap_pct > 0:
            # Gap UP -> fade down -> BUY PUT
            signal_type = SignalType.BUY_PUT
            reason = f"Gap up {self.gap_pct:.2f}% - fading with put"
        else:
            # Gap DOWN -> fade up -> BUY CALL
            signal_type = SignalType.BUY_CALL
            reason = f"Gap down {self.gap_pct:.2f}% - fading with call"

        logger.info(f"Gap Fade Signal: {signal_type.name} - {reason}")

        return GapSignal(
            signal_type=signal_type,
            timestamp=bar_time,
            price=bar["close"],
            gap_pct=self.gap_pct,
            prior_close=self.prior_close,
            current_open=self.current_open,
            reason=reason,
        )

    def get_gap_info(self) -> Optional[dict]:
        """Get current gap information."""
        return {
            "prior_close": self.prior_close,
            "current_open": self.current_open,
            "gap_pct": self.gap_pct,
            "state": self.state.value,
            "entries_today": self.entries_today,
        }

    def is_gap_detected(self) -> bool:
        """Check if a tradeable gap has been detected today."""
        return self.state in (
            GapState.GAP_DETECTED,
            GapState.WAITING_FOR_ENTRY,
            GapState.SIGNAL_FIRED,
        )
