"""
Opening Range Breakout (ORB) Signal Generator for 0DTE Options.

ORB Strategy Rules:
1. Track high/low from 9:30-10:30 AM ET (first 60 minutes)
2. After range is defined, watch for bar CLOSE above range high or below range low
3. On breakout UP → BUY CALL signal
4. On breakout DOWN → BUY PUT signal
5. Multiple entries allowed if stopped out and new breakout occurs
6. No new entries after entry cutoff (default 1 PM ET)
"""

from typing import Optional, List, Tuple
from datetime import datetime, time, timedelta
from dataclasses import dataclass
from enum import Enum
import logging

from app.models.schemas import SignalType

logger = logging.getLogger(__name__)


# Market hours in ET (Eastern Time)
MARKET_OPEN_ET = time(9, 30)
DEFAULT_RANGE_END_ET = time(10, 30)  # 60 minute range
DEFAULT_ENTRY_CUTOFF_ET = time(13, 0)  # 1 PM ET


class ORBState(Enum):
    """State of the ORB strategy for the current day."""
    BUILDING_RANGE = "building_range"
    WATCHING_FOR_BREAKOUT = "watching_for_breakout"
    BREAKOUT_UP = "breakout_up"
    BREAKOUT_DOWN = "breakout_down"
    CUTOFF_REACHED = "cutoff_reached"


@dataclass
class ORBRange:
    """Opening Range data for a trading day."""
    date: datetime
    high: float
    low: float
    range_size: float
    range_end_time: datetime
    open_price: float  # First bar open

    @property
    def midpoint(self) -> float:
        return (self.high + self.low) / 2


@dataclass
class ORBSignal:
    """Signal generated by ORB strategy."""
    signal_type: SignalType
    timestamp: datetime
    price: float
    range_high: float
    range_low: float
    reason: str


class ORBSignalGenerator:
    """
    Generate trading signals based on Opening Range Breakout.

    Usage:
        generator = ORBSignalGenerator(range_minutes=60)

        for bar in bars:
            signal = generator.process_bar(bar)
            if signal:
                # Execute trade
    """

    def __init__(
        self,
        range_minutes: int = 60,
        entry_cutoff_hour_utc: int = 18,  # 1 PM ET = 18:00 UTC
        breakout_buffer: float = 0.0,  # Minimum amount above/below range to confirm
        require_close: bool = True,  # Require bar CLOSE above/below range
    ):
        """
        Initialize ORB Signal Generator.

        Args:
            range_minutes: Duration of opening range (30 or 60 minutes typical)
            entry_cutoff_hour_utc: Hour (UTC) after which no new entries allowed
            breakout_buffer: Extra buffer required beyond range high/low
            require_close: If True, bar must CLOSE above/below range (more conservative)
        """
        self.range_minutes = range_minutes
        self.entry_cutoff_hour_utc = entry_cutoff_hour_utc
        self.breakout_buffer = breakout_buffer
        self.require_close = require_close

        # State tracking
        self.current_date: Optional[datetime] = None
        self.range: Optional[ORBRange] = None
        self.state: ORBState = ORBState.BUILDING_RANGE
        self.range_bars: List[dict] = []
        self.last_breakout_direction: Optional[str] = None

        # Tracking for multiple entries
        self.entries_today: int = 0
        self.max_entries_per_day: int = 3

    def reset_for_new_day(self) -> None:
        """Reset state for a new trading day."""
        self.current_date = None
        self.range = None
        self.state = ORBState.BUILDING_RANGE
        self.range_bars = []
        self.last_breakout_direction = None
        self.entries_today = 0

    def process_bar(self, bar: dict) -> Optional[ORBSignal]:
        """
        Process a price bar and potentially generate a signal.

        Args:
            bar: Price bar with keys: timestamp, open, high, low, close

        Returns:
            ORBSignal if a breakout is detected, None otherwise
        """
        bar_time = bar["timestamp"]
        if isinstance(bar_time, str):
            bar_time = datetime.fromisoformat(bar_time.replace("Z", "+00:00"))

        # Check for new day
        bar_date = bar_time.date()
        if self.current_date is None or bar_date != self.current_date:
            self.reset_for_new_day()
            self.current_date = bar_date

        # Check entry cutoff
        if bar_time.hour >= self.entry_cutoff_hour_utc:
            self.state = ORBState.CUTOFF_REACHED
            return None

        # State machine
        if self.state == ORBState.BUILDING_RANGE:
            return self._handle_building_range(bar, bar_time)
        elif self.state == ORBState.WATCHING_FOR_BREAKOUT:
            return self._handle_watching_for_breakout(bar, bar_time)
        elif self.state in (ORBState.BREAKOUT_UP, ORBState.BREAKOUT_DOWN):
            return self._handle_post_breakout(bar, bar_time)

        return None

    def _handle_building_range(self, bar: dict, bar_time: datetime) -> Optional[ORBSignal]:
        """Build the opening range from initial bars."""
        self.range_bars.append(bar)

        # Check if range period has elapsed (TIME-BASED, not bar count)
        # This works correctly regardless of bar timeframe (1-min, 5-min, etc.)
        if self.range_bars:
            first_bar_time = self.range_bars[0]["timestamp"]
            if isinstance(first_bar_time, str):
                first_bar_time = datetime.fromisoformat(first_bar_time.replace("Z", "+00:00"))

            # Calculate minutes elapsed since first bar
            minutes_elapsed = (bar_time - first_bar_time).total_seconds() / 60

            # Finalize range when we've passed the range period
            if minutes_elapsed >= self.range_minutes:
                self._finalize_range(bar_time)
                self.state = ORBState.WATCHING_FOR_BREAKOUT
                logger.info(
                    f"ORB Range defined: High={self.range.high:.2f}, "
                    f"Low={self.range.low:.2f}, Size={self.range.range_size:.2f}"
                )

        return None

    def _finalize_range(self, current_time: datetime) -> None:
        """Calculate final opening range from collected bars."""
        if not self.range_bars:
            return

        highs = [bar["high"] for bar in self.range_bars]
        lows = [bar["low"] for bar in self.range_bars]
        open_price = self.range_bars[0]["open"]

        range_high = max(highs)
        range_low = min(lows)

        self.range = ORBRange(
            date=current_time,
            high=range_high,
            low=range_low,
            range_size=range_high - range_low,
            range_end_time=current_time,
            open_price=open_price,
        )

    def _handle_watching_for_breakout(self, bar: dict, bar_time: datetime) -> Optional[ORBSignal]:
        """Watch for price breaking out of the range."""
        if self.range is None:
            return None

        # Check for max entries
        if self.entries_today >= self.max_entries_per_day:
            return None

        bar_close = bar["close"]
        bar_high = bar["high"]
        bar_low = bar["low"]

        # Determine breakout level to check
        if self.require_close:
            check_up = bar_close
            check_down = bar_close
        else:
            check_up = bar_high
            check_down = bar_low

        # Check for breakout UP
        breakout_up_level = self.range.high + self.breakout_buffer
        if check_up > breakout_up_level:
            self.state = ORBState.BREAKOUT_UP
            self.last_breakout_direction = "up"
            self.entries_today += 1

            return ORBSignal(
                signal_type=SignalType.BUY_CALL,
                timestamp=bar_time,
                price=bar_close,
                range_high=self.range.high,
                range_low=self.range.low,
                reason=f"ORB breakout UP: Close ${bar_close:.2f} > Range high ${self.range.high:.2f}",
            )

        # Check for breakout DOWN
        breakout_down_level = self.range.low - self.breakout_buffer
        if check_down < breakout_down_level:
            self.state = ORBState.BREAKOUT_DOWN
            self.last_breakout_direction = "down"
            self.entries_today += 1

            return ORBSignal(
                signal_type=SignalType.BUY_PUT,
                timestamp=bar_time,
                price=bar_close,
                range_high=self.range.high,
                range_low=self.range.low,
                reason=f"ORB breakout DOWN: Close ${bar_close:.2f} < Range low ${self.range.low:.2f}",
            )

        return None

    def _handle_post_breakout(self, bar: dict, bar_time: datetime) -> Optional[ORBSignal]:
        """
        Handle state after a breakout has occurred.

        Allow re-entry if price returns to range and breaks out again.
        """
        if self.range is None:
            return None

        bar_close = bar["close"]

        # Check if price has re-entered the range (potential for new breakout)
        if self.range.low <= bar_close <= self.range.high:
            # Price back in range - go back to watching
            self.state = ORBState.WATCHING_FOR_BREAKOUT
            logger.debug(f"Price re-entered range at ${bar_close:.2f}")

        return None

    def get_range_info(self) -> Optional[dict]:
        """Get current range information."""
        if self.range is None:
            return None

        return {
            "high": self.range.high,
            "low": self.range.low,
            "range_size": self.range.range_size,
            "midpoint": self.range.midpoint,
            "open_price": self.range.open_price,
            "state": self.state.value,
            "entries_today": self.entries_today,
        }

    def is_range_defined(self) -> bool:
        """Check if opening range has been defined."""
        return self.range is not None

    def get_breakout_targets(self) -> Optional[Tuple[float, float]]:
        """
        Get the breakout target prices.

        Returns:
            Tuple of (upside_breakout_level, downside_breakout_level)
        """
        if self.range is None:
            return None

        up_level = self.range.high + self.breakout_buffer
        down_level = self.range.low - self.breakout_buffer
        return (up_level, down_level)


def generate_orb_signals(
    bars: List[dict],
    range_minutes: int = 60,
    entry_cutoff_hour_utc: int = 18,
    require_close: bool = True,
) -> List[ORBSignal]:
    """
    Generate all ORB signals for a series of bars.

    Convenience function for backtesting.

    Args:
        bars: List of price bars (sorted by time, oldest first)
        range_minutes: Opening range duration
        entry_cutoff_hour_utc: Entry cutoff hour (UTC)
        require_close: Require bar close for breakout confirmation

    Returns:
        List of ORB signals generated
    """
    generator = ORBSignalGenerator(
        range_minutes=range_minutes,
        entry_cutoff_hour_utc=entry_cutoff_hour_utc,
        require_close=require_close,
    )

    signals = []
    for bar in bars:
        signal = generator.process_bar(bar)
        if signal:
            signals.append(signal)

    return signals
